import * as t from 'assert';
import { parseScript, recovery } from '../../../src/escaya';

describe('Expressions - Optional chaining', () => {
  // Invalid cases
  for (const arg of [
    'value?.`foo`',
    'value?.bar`tag`',
    '[] += a',

    'a.b.?.c.d',
    'a:?.b',
    '[x?.?.y = 1]',
    'a ? .5;',
    'a.?2.3',
    'a.? (?) [?]',
    '{a: 44}?.a',
    'a?.b++;',
    '--a?.b;',
    'a:?.b',
    'a:?[b]',
    '?. ?[] ?() ?:',
    'a ? .5;',
    'class a extends b { c() { [super?.d] = e } }',

    'for ({ x: { set y(val) {} }?.y} in [{x: 42}]) ;',
    'for ([x?.y = 42] of [[23]]) ;',
    'for ([x?.y] of [[23]]) ;',
    'for ([{ set y(val) {}}?.y = 42] of [[23]]) ;',
    'for ([{ set y(val) { }}?.y] of [[23]]) ;',
    'for ({ x: y?.z = 42 } of [{ x: 23 }]) ;',
    'for ({ x: y?.z } of [{ x: 23 }]) ;',
    'for ({ x: {set y(val) { }}?.y = 42} of [{x: 42}]) ;',
    'for ({ x: { set y(val) {}}?.y} of [{x: 42}]) ;',
    '0, [x?.y] = [23];',
    '0, [x?.y = 42] = [23];',
    '0, { x: { set y(val) {}}?.y} = {x: 42};',
    '0, [{ set y(val) {}}?.y] = [23];',
    'async?.(async?.(), async?.[])',
    'yield?.await = foo',
    'async?.await = foo',
    'async?.[x] = foo',
    'async?.() = foo',
    'a.?2.3',
    'a.?.2',
    'a.?2.n',
    'a.?2.3',
    'class C {} class D extends C { foo() { return super?.["bar"]; } }',
    // 'const o = { C: class {} }; new o?.C();',
    // 'const o = { C: class {} }; new o?.["C"]();',
    'let [...[...[...x?.a]]] = [x?.[[]]];',
    'obj?.a = 33;',

    'a.?2.3',
    '{a: 44}?.a',
    'let obj = {x:x?.1}; [...obj["x"]] = [10];',
    'let [...[...[...x?.a]]] = [x?.[[]]];',
    'let [...[...[...x?.a]]] = [[[]]];',
    'let [...[...[...x]]] = [?.a[[]]];',
    'try {} catch ([e?.a, ...a]) {}',
    'try {} catch (a?.[e]) {}',
    '[...[{x?.prop: 1}.prop]] = []',
    '[...[{prop?.a: 1}.prop]] = []',
    '[...[{prop: 1}.prop]] = x?.[]',
    // 'obj?.[expr] func?.(...args) new C?.(...args)',
    'o.x?[y]+z',
    'obj:?.prop',
    'obj:?[expr]',
    'func:?(...args)',
    'a === null: a?.b.c === undefined',
    'a === null: a?.b.c === undefined',
    '?.a?.b?.c',
    '[...[{x?.prop: 1}.prop]] = []',
    '[...[{prop?.a: 1}.prop]] = []',
    '[...[{prop: 1}.prop]] = x?.[]',
    // 'obj?.[expr] func?.(...args) new C?.(...args)',
    'o.x?[y]+z',
    'obj:?.prop',
    'obj:?[expr]',
    'func:?(...args)',
    'a === null: a?.b.c === undefined',
    'a === null: a?.b.c === undefined',
    '?.a?.b?.c',
    '?.(a.b.c)',
    '?. ?[] ?() ?:',
    //'var b = condition ? a?.x.?y : a?.y?.z;',
    'a.?[b.c].d',
    'a[?b[c]]',
    'delete ?a.b.c',
    'delete ?a.b.c',
    '[x?.y = 1]',
    '[x?.x?.y = 1]',
    '[x?.?.y = 1]',
    '[x?.y = 1]',
    'a?.b => (a == null ? a : a.b)',
    'foo?.x?.y?.z?()=>foo;',
    'const a = { b(){ return super?.c; } }',
    'class A{ b(){ return super?.b; } }',
    //'new a?.();',
    //'new C?.b.d()',
    'a.?b.?()',
    'a.?()',
    'a?.b = c',
    'a?.{a} = c',
    'a?.(a) = c',
    'a?.b => (a == null ? void 0 : a.b) a?.b.c => (a == null ? void 0 : a.b.c)',
    "({ a: x?.obj['a'] } = {})",
    '[...[x?.this[0], ...x?.this[1]]] = []',
    'class C {} class D extends C { foo() { return super?.bar; } }',
    'class C {} class D extends C { foo() { return super?.["bar"]; }',
    'class C {} class D extends C { constructor() { super?.(); } }',
    // 'const o = { C: class {} }; new o?.C();',
    // 'const o = { C: class {} }; new o?.["C"]();',
    // 'class C {} new C?.();',
    'function tag() {} tag?.``',
    'const o = { tag() {} }; o?.tag``',
    'import?.("foo")',
    'value?.foo`bar`',
    // 'a?.?.b',
    // 'new new class {}()?.constructor?.();',
    'async(x?.x)=>x?.z',
    'a?.{a} = c'
  ]) {
    it(`${arg}`, () => {
      t.throws(() => {
        parseScript(`${arg}`);
      });
    });
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        recovery(`${arg}`, 'recovery.js');
      });
    });
  }

  // Valid cases. Testing random cases to verify we have no issues with bit masks
  for (const arg of [
    'null?.(1, ...a)',
    'arr?.[0]',
    'obj?.[undefined]',
    'arr ?. length',
    `['hi']?.[0]`,
    `() => true?.()`,
    `null?.()().a['b']`,
    'value?.()',
    'value?.[foo]',
    `({}).a?.(...a)`,
    `({ x: 'hi' })?.['x']`,
    `({})?.constructor`,
    `0?.valueOf()`,
    'value?.(x)',
    `null?.valueOf()`,
    `1?.valueOf()`,
    '(a?.b)?.c.d.e;',
    '(a?.b?.c).d.e;',
    '((a?.b)?.c).d.e;',
    'value?.foo.bar',
    'value?.(foo).bar',
    'value?.[foo](bar)',
    'value?.foo(bar)',
    'value?.(foo)(bar)',
    'value?.foo[bar]',
    'value?.[foo][bar]',
    'value?.(foo)[bar]',
    'value?.[x]',
    `null?.a`,
    `(obj?.a)?.b`,
    `({})?.['a']?.b`,
    `(fn()?.a)?.b`,
    `(function * a () {}?.name)`,
    `o3?.a?.b === o4?.a?.b === undefined`,
    `x in (o3?.a)`,
    `a?.[++x]`,
    `a?.b.c(++x).d;`,
    `undefined?.[++x]`,
    `foo?.x?.y?.z?()=>{foo}:bar;`,
    `if (a?.b?.c === 'foobar') {}`,
    `[a, ...b] = [1, 2?.a, 3];`,
    `({ a: null }).a?.(...a)`,
    `() => 5?.(...[])`,
    'value?.super',
    'a?.b.c',
    'a.b?.c',
    'a?.b?.c',
    `0?.()`,
    `0?.valueOf()`,
    `false?.()`,
    `[]?.()`,
    'a?.b.c;',
    `(a?.b).c;`,
    `(a?.b).c();`,
    `a?.b[3].c?.(x).d`,
    `(obj?.foo).bar++`,
    `(obj?.foo).bar = 0`,
    `false?.4:5`,
    `class Foo extends Base { method() { super.method?.(); } }`,
    `class Foo extends Base { method() { super.method?.(); } }`,
    `delete o1?.x`,
    `delete o1.z?.()`,
    `func?.()`,
    `arr?.[i + 1]`,
    `arr[0]?.a`,
    //`function a(b) { new.target?.(); }`,
    `obj?.aaa?.bbb`
  ]) {
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        parseScript(`${arg}`);
      });
    });
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        recovery(`${arg}`, 'recovery.js');
      });
    });
  }
});
