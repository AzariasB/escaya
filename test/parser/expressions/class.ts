import * as t from 'assert';
import { parseScript, recovery } from '../../../src/escaya';

describe('Declarations - Class', () => {
  // Invalid cases
  for (const arg of [
    'class l\\u0065t {}',
    '[,',
    '[] += a',

    '(class {*async x(){}})',
    '(class {async *(){}})',
    '(class {async get x(){}})',
    '(class {async set x(y){}})',
    '(class {async static x(){}})',
    '(class {static async get x(){}})',
    '(class {static async set x(y){}})',
    '(class {static *async x(){}})',
    '(class {static get *(){}})',
    '(class {static set *(){}})',
    'class C { get name(public) {} }',
    'class C { get name(static) {} }',
    'class C { get name(implements) {} }',
    'class C { get name(let) {} }',
    '(class C {static prototype() {}})',
    '(class C {static get prototype() {}})',
    '(class C {static set prototype(_) {}})',
    '(class C {static *"prototype"() {})',
    '(class C {static prot\\u006ftype() {}})',
    '(class C {get constructor() {}})',
    '(class C {*constructor() {}})',
    '(class C {*"constructor"() {}})',
    '(class {async *method([...x = []] = []) {}})',
    '(class {static async *gen() { await: ; }})',
    '(class {async "constructor"(){}})',
    '(class {*method([...{ x }, y]) {}})',
    '(class {static *method([...[ x ] = []]) {}})',
    '(class {[a,b](){}})',
    '(class {class name {})',
    '(class {static async *method([...{ x } = []] = []) {}})',
    '(class {static async *method([...x = []] = []) {}})',
    '(class {static async *method([...x, y]) {}})',
    '(class {static async method(...a,) {}})',
    'class',
    '(class b )',
    '(class b {-})',
    '(class b {a:})',
    '(class b {#a:})',
    '(class extends a,b {)',
    '(class eval {a:0})',
    'class x{async *%x(a){}}',
    '(class x{async *%x(a){}})`;',
    '(class x {[x]z){}})',
    '(class x {foo})',
    '(class x { y; })',
    //'(class x { `constructor`(){} })',
    //  '(class A {set prototype(x){}})',
    '(class A {* set 12(x){}})',
    //'(class A {constructor(){}; constructor(){}})',
    //'(class A {a(){}; constructor(){}; constructor(){}})',
    //'(class A {a(){}; constructor(){}; a(){}; a(){}; a(){}; constructor(){}; a(){}})',
    //'(class A {static constructor(){}; constructor(){}; constructor(){}})',
    '(class A {foo, bar(){}})',
    'class x { foo(x=await y){} }',
    'class A {...',
    '(class A {* set [foo](x){}})',
    '(class A {async get [foo](){}})',
    '(class x{get *foo(){}})',
    '(class x{get *[x](){}})',
    '(class x{get *"foo"(){}})',
    '(class x{get *555(){}})',
    '(class x{set *foo(a){})',
    '(class x{set *[x](a){}})',
    '(class x{set *"foo"(a){}})',
    '(class x{set *555(a){}})',
    '(class x{set *%x(a){}})',

    '(class x{static *%x(){}})',
    '(class v extends.foo {})',
    '(class x{static get *foo(){}})',
    '(class x{static get *[x](){}}`);',
    '(class x{static get *"foo"(){}})',
    '(class x{static get *555(){}})',
    '0, class { static method(...x = []) {} };',
    '0, class { static method(...a,) {} };',
    'class x{static get *%x(){}}',
    '(class x{static set *foo(a){}})',
    '(class x{static set *[x](a){}})',
    '(class x{static set *"foo"(a){}})',
    '(class x{static set *555(a){}})',
    '(class x{static set *%x(a){}})',
    '(class A extends B { method() { super() } })',
    '(class x{static async *%x(a){}})',
    '(class x{static async *%x(a){}})',
    '(class x{async *get 8(){}})',
    '(class x{static *async 8(){}})',
    '(class x{static *get 8(){}})',
    '(class x{static *set 8(y){}})',
    '(class x{static *async "x"(){}})',
    '(class x{static *get "x"(){}}',
    '(class { static *get [x](){}})',
    '(class { static *get [x](){}}) (class { static *get [x](){}})',
    'var foo = (class { static *get [x](){}})',
    '(class { static *set [x](y){}})',
    'function foo() { (class { static *get [x](){}}) }',
    '(class { static *set [x](y){}}) (class { static *set [x](y){}})',
    'var foo = (class { static *set [x](y){}})',
    'function foo() { (class { static *set [x](y){}}) }',
    '(class A { ["async"] a() {} })',
    '(class A { ["get"] a() {} })',
    '(class A { static prototype() {} })',
    '(class A { static get prototype() {} })',
    '(class A { static set prototype(_) {} })',
    // '(class A { static *prototype() {} })',
    '(class A { static prototype() {} })',
    '(class A { static *set [x](y){}})',
    '(class A { static *get [x](){} })',
    '(class A {async *constructor(){}})',
    '(class A {get "constructor"(){}})',
    //'(class x { async prototype(){} })',
    'class x {    * * f(){}    }',
    'class x { static set prototype(x){} }',
    //'class x { static prototype(){} }',
    'class x {foo: x}',
    '(class A {* get foo(){}})',
    '(class A {set constructor(x){}})',
    '(class A {get constructor(){}})',
    '(class A {async get foo(){}})',
    '(class A {* get "foo"(){}})',
    '(class A {async set "foo"(x){}})',
    '(class A {* set "foo"(x){}})',
    '(class A {async get 7(){}})',
    'class name',
    'class name extends',
    'class extends',
    'class name {',
    'class name { m }',
    'class name { m; n }',
    'class name { m: 1 }',
    'class name { m(); n() }',
    'class static {}'
  ]) {
    it(`${arg}`, () => {
      t.throws(() => {
        parseScript(`${arg}`);
      });
    });
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        recovery(`${arg}`, 'recovery.js');
      });
    });
  }

  // Valid cases. Testing random cases to verify we have no issues with bit masks
  for (const arg of [
    '(class x {})',
    '(class x extends y {})',
    '(class x { a() {}})',
    'class n extends ([] = x) {}',
    'class n extends ({} = x) {}',
    'f = ([cls = class {}, xCls = class X {}, xCls2 = class { static name() {} }]) => {}',
    '(class o {f(){ function x(){}}})',
    '(class A {async * 34(){}})',
    '(class A {set [foo](x){}})',
    '(class X {})',
    '(class x{}())',
    '(class A {set prototype(x){}})',
    '(class x{}.foo())',
    'x = class{} / x',
    'class x { get prototype(){} }',
    '(class x { async prototype(){} })',
    '(class A {static 2(){}})',
    '(class x { get [y](){}})',
    '(class x{*[x](){}})',
    '(class {})',
    '(class name {})',
    '(class extends F {})',
    '(class name extends F {})',
    '(class extends (F, G) {})',
    '(class name extends (F, G) {})',
    '(class extends class {} {})',
    '(class name extends class {} {})',
    '(class extends class base {} {})',
    '(class name extends class base {} {})',
    '(class {function() {}});',
    '(class {if() {}});',
    '(class {42.5() {}});',
    '(class {1n() {}});',
    '(class {42e+2() {}});',
    '(class {null() {}});',
    '(class {"string"() {}});',
    '(class {static() {}});',
    '(class {get() {}});',
    '(class {var() {}});',
    '(class {const() {}});',
    '(class {public() {}});',
    '(class {private() {}});',
    '(class {class() {}});',
    '(class {await() {}});'
  ]) {
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        parseScript(`${arg}`);
      });
    });
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        recovery(`${arg}`, 'recovery.js');
      });
    });
  }
});
