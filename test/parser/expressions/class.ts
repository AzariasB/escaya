import * as t from 'assert';
import { parseScript, recovery } from '../../../src/escaya';

describe('Declarations - Class', () => {
  // Invalid cases
  for (const arg of [
    'class l\\u0065t {}',
    '[,',
    '[] += a',
    '(class {*async x(){}})',
    '(class {async *(){}})',
    '(class {async get x(){}})',
    '(class {async set x(y){}})',
    '(class {async static x(){}})',
    '(class {static async get x(){}})',
    '(class {static async set x(y){}})',
    '(class {static *async x(){}})',
    '(class {static get *(){}})',
    '(class {static set *(){}})',
    'class C { get name(public) {} }',
    'class C { get name(static) {} }',
    '(class { async constructor(){} })',
    '(class let {})',
    '(class yield {})',
    '"use strict"; (class package{})',
    '"use strict"; (class implements{})',
    '"use strict"; (class yield{})',
    '(class { async\na(){} })',
    '(class { async get a(){} })',
    '(class { async })',
    'class C { get name(implements) {} }',
    'class C { get name(let) {} }',
    '(class C {static prototype() {}})',
    '(class {foo(...a,) {}})',
    '(class {static foo(...a,) {}})',
    // It is a Syntax Error if StatementList Contains super unless the source code containing super
    // is eval code that is being processed by a direct eval that is contained in function code.
    '(class {[super.a](){}});',
    '(class {a(b = super()){}});',
    '(class {[super()](){}});',
    '(class C {static get prototype() {}})',
    '(class C {static set prototype(_) {}})',
    '(class C {static *"prototype"() {})',
    '(class C {static prot\\u006ftype() {}})',
    '(class C {get constructor() {}})',
    '(class C {*constructor() {}})',
    '(class C {*"constructor"() {}})',
    '(class {async *method([...x = []] = []) {}})',
    '(class {static async *gen() { await: ; }})',
    '(class {async "constructor"(){}})',
    '(class {*method([...{ x }, y]) {}})',
    '(class {static *method([...[ x ] = []]) {}})',
    '(class {[a,b](){}})',
    '(class {class name {})',
    '(class {static async *method([...{ x } = []] = []) {}})',
    '(class {static async *method([...x = []] = []) {}})',
    '(class {static async *method([...x, y]) {}})',
    '(class {static async method(...a,) {}})',
    'class',
    '(class b )',
    '(class b {-})',
    '(class b {a:})',
    '(class b {#a:})',
    '(class extends a,b {)',
    '(class eval {a:0})',
    'class x{async *%x(a){}}',
    '(class x{async *%x(a){}})`;',
    '(class x {[x]z){}})',
    '(class x {foo})',
    '(class x { y; })',
    //'(class x { `constructor`(){} })',
    //  '(class A {set prototype(x){}})',
    '(class A {* set 12(x){}})',
    //'(class A {constructor(){}; constructor(){}})',
    //'(class A {a(){}; constructor(){}; constructor(){}})',
    //'(class A {a(){}; constructor(){}; a(){}; a(){}; a(){}; constructor(){}; a(){}})',
    //'(class A {static constructor(){}; constructor(){}; constructor(){}})',
    '(class A {foo, bar(){}})',
    'class x { foo(x=await y){} }',
    'class A {...',
    '(class A {* set [foo](x){}})',
    '(class A {async get [foo](){}})',
    '(class x{get *foo(){}})',
    '(class x{get *[x](){}})',
    '(class x{get *"foo"(){}})',
    '(class x{get *555(){}})',
    '(class x{set *foo(a){})',
    '(class x{set *[x](a){}})',
    '(class x{set *"foo"(a){}})',
    '(class x{set *555(a){}})',
    '(class x{set *%x(a){}})',
    '(class x{static *%x(){}})',
    '(class v extends.foo {})',
    '(class x{static get *foo(){}})',
    '(class x{static get *[x](){}}`);',
    '(class x{static get *"foo"(){}})',
    '(class x{static get *555(){}})',
    '0, class { static method(...x = []) {} };',
    '0, class { static method(...a,) {} };',
    'class x{static get *%x(){}}',
    '(class x{static set *foo(a){}})',
    '(class x{static set *[x](a){}})',
    '(class x{static set *"foo"(a){}})',
    '(class x{static set *555(a){}})',
    '(class x{static set *%x(a){}})',
    '(class A extends B { method() { super() } })',
    '(class x{static async *%x(a){}})',
    '(class x{static async *%x(a){}})',
    '(class x{async *get 8(){}})',
    '(class x{static *async 8(){}})',
    '(class x{static *get 8(){}})',
    '(class x{static *set 8(y){}})',
    '(class x{static *async "x"(){}})',
    '(class x{static *get "x"(){}}',
    '(class { static *get [x](){}})',
    '(class { static *get [x](){}}) (class { static *get [x](){}})',
    'var foo = (class { static *get [x](){}})',
    '(class { static *set [x](y){}})',
    'function foo() { (class { static *get [x](){}}) }',
    '(class { static *set [x](y){}}) (class { static *set [x](y){}})',
    'var foo = (class { static *set [x](y){}})',
    'function foo() { (class { static *set [x](y){}}) }',
    '(class A { ["async"] a() {} })',
    '(class A { ["get"] a() {} })',
    '(class A { static prototype() {} })',
    '(class A { static get prototype() {} })',
    '(class A { static set prototype(_) {} })',
    // '(class A { static *prototype() {} })',
    '(class A { static prototype() {} })',
    '(class A { static *set [x](y){}})',
    '(class A { static *get [x](){} })',
    '(class A {async *constructor(){}})',
    '(class A {get "constructor"(){}})',
    //'(class x { async prototype(){} })',
    'class x {    * * f(){}    }',
    'class x { static set prototype(x){} }',
    //'class x { static prototype(){} }',
    'class x {foo: x}',
    '(class A {* get foo(){}})',
    '(class A {set constructor(x){}})',
    '(class A {get constructor(){}})',
    '(class A {async get foo(){}})',
    '(class A {* get "foo"(){}})',
    '(class A {async set "foo"(x){}})',
    '(class A {* set "foo"(x){}})',
    '(class A {async get 7(){}})',
    'class name',
    'class name extends',
    'class extends',
    'class name {',
    'class name { m }',
    'class name { m; n }',
    'class name { m: 1 }',
    'class name { m(); n() }',
    'class static {}'
  ]) {
    it(`${arg}`, () => {
      t.throws(() => {
        parseScript(`${arg}`);
      });
    });
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        recovery(`${arg}`, 'recovery.js');
      });
    });
  }

  // Valid cases. Testing random cases to verify we have no issues with bit masks
  for (const arg of [
    '(class x {}())',
    '(class x extends y {})',
    '(class x { a() {}})',
    'class n extends ([] = x) {}',
    'class n extends ({} = x) {}',
    '(class extends a { constructor() {}  *i() {}  })',
    //'(class extends a { constructor() {}  *[i]() {}  })',
    'f = ([cls = class {}, xCls = class X {}, xCls2 = class { static name() {} }]) => {}',
    '(class o {f(){ function x(){}}})',

    '(class extends Base {set x(v) {}});',
    '(class {set x(v) {}});',
    'class C {; *g() {}}',
    'class C extends Base {; *g() {}}',
    '(class {; *g() {}});',
    '(class extends Base {*g() {}; *h(x) {}});',
    '(class {*g() {}; *h(x) {}});',
    'class C {*g() {}; *h(x) {}}',
    'class C extends Base {async *x(){}}',
    '(class {async *x(){}});',
    '(class extends Base {async *x(){}});',
    '(class {static get x() {}});',
    'class C {static get x() {}}',
    'class C extends Base {static get x() {}}',
    '(class {static set x(v) {}});',
    '(class extends Base {static set x(v) {}});',
    '(class {static set await(v) {}});',
    'class C {static set await(v) {}}',
    'class C extends Base {*get() {}}',
    '(class {*get() {}});',
    '(class extends Base {*get() {}});',
    '(class {st\\u0061tic() {}});',
    'class C {st\\u0061tic() {}}',
    'class C extends Base {static set st\\u0061tic(v) {}}',
    '(class {static async x(){}});',
    '(class extends Base {static async x(){}});',
    '(class {static async(){}});',
    'class C {static async(){}}',
    'class C extends Base {static async *x(){}}',
    '(class {static async *x(){}});',
    '(class extends Base {async async(){}});',
    '(class {async async(){}});',
    'class C {async async(){}}',
    'class C extends Base {async(){}}',
    '(class {async(){}});',
    '(class extends Base {async(){}});',
    '(class {*async(){}});',
    'class C {*async(){}}',
    'class C extends Base {*async(){}}',
    '(class {static get static() {}});',
    '(class extends Base {static get static() {}});',
    '(class {static get static() {}});',
    'class C {static set x(v) {}}',
    'class C extends Base {static set x(v) {}}',
    '(class A {async * 34(){}})',
    '(class A {set [foo](x){}})',
    '(class X {})',
    '(class x{}())',

    '(class {42() {}});',
    '(class { get 4256n() {}});',
    '(class { set 4256n(v) {}});',
    '(class { static get 42.5() {}});',
    '(class { static set 42.5(v) {}});',
    '(class { *42.5() {}});',
    '(class { static *42e2() {}});',
    'class C {42e2() {}}',
    'class C { get 42e2() {}}',
    'class C { static set 42e+2(v) {}}',
    'class C { *42e+2() {}}',
    '(class {42e-2() {}});',
    '(class { get 42e-2() {}});',
    '(class { set 42e-2(v) {}});',
    '(class { static get null() {}});',
    '(class { static set null(v) {}});',
    '(class { *get() {}});',
    '(class { static *get() {}});',
    'class C {get() {}}',
    'class C { get static() {}}',
    'class C { static set static(v) {}}',
    'class C { *static() {}}',
    '(class {else() {}});',
    '(class { get else() {}});',
    '(class { set function(v) {}});',
    '(class { static get finally() {}});',
    '(class { static set let(v) {}});',
    '(class { *let() {}});',
    '(class { static *const() {}});',
    'class C {const() {}}',
    'class C { get set() {}}',
    '(class  {set 4256n(v) {}});',
    'class C { static set true(v) {}}',
    'class C { *"string"() {}}',
    '(class A {set prototype(x){}})',
    '(class x{}.foo())',
    'x = class{} / x',
    'class x { get prototype(){} }',
    '(class x { async prototype(){} })',
    '(class A {static 2(){}})',
    '(class x { get [y](){}})',
    '(class x{*[x](){}})',
    `(class Foo {}?.name)`,
    '(class {})',
    '(class { async(){} })',
    '(class { async a(){} })',
    '(class { static async a(){} })',
    '(new class {\nget static() {}\n}).static',
    '(new class {\nst\\u0061tic() { return "method-static-escape"; }\n})',
    '(class basic {constructor() { } })',
    '(class nullExtends extends null { constructor() { } })',
    '(class name {})',
    '(class extends F {})',
    '(class name extends F {})',
    '(class extends (F, G) {})',
    '(class name extends (F, G) {})',
    '(class extends class {} {})',
    '(class name extends class {} {})',
    '(class extends class base {} {})',
    '(class name extends class base {} {})',
    '(class {function() {}});',
    '(class {if() {}});',
    '(class {42.5() {}});',
    '(class {1n() {}});',
    '(class {42e+2() {}});',
    '(class {null() {}});',
    '(class x {}.foo)',
    '(class x {}.foo())',
    '(class {"string"() {}});',
    '(class {static() {}});',
    '(class {get() {}});',
    '(class {var() {}});',
    '(class {const() {}});',
    '(class {public() {}});',
    '(class {private() {}});',
    '(class {class() {}});',
    '(class {await() {}});',
    '(class {for() {}});',
    '(class {interface() {}});',
    '(class {yield() {}});',
    '(class {new() {}});',
    '(class {continue() {}});',
    '(class {throw() {}});'
  ]) {
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        parseScript(`${arg}`);
      });
    });
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        recovery(`${arg}`, 'recovery.js');
      });
    });
  }
});
